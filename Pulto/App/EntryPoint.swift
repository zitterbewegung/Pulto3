//  EntryPoint.swift
//  Pulto3
//
//  Created by Joshua Herman on 7/16/25.
//  Copyright Apple. All rights reserved.
//

import SwiftUI
import RealityKit
import AVFoundation

// === BEGIN: Notebook JSON Environment Key (add once) ===
private struct GenerateNotebookJSONKey: EnvironmentKey {
    static let defaultValue: () -> String = { "{}" }
}
extension EnvironmentValues {
    var generateNotebookJSON: () -> String {
        get { self[GenerateNotebookJSONKey.self] }
        set { self[GenerateNotebookJSONKey.self] = newValue }
    }
}
// === END: Notebook JSON Environment Key ===

// MARK: - Notification Extensions
extension Notification.Name {
    static let reopenMainWindow = Notification.Name("reopenMainWindow")
    static let appWillEnterBackground = Notification.Name("appWillEnterBackground")
    static let appDidBecomeActive = Notification.Name("appDidBecomeActive")
}

@MainActor
func makeNotebookJSON(from windowManager: WindowTypeManager) -> String {
    var cells: [[String: Any]] = []

    if let project = windowManager.selectedProject {
        cells.append([
            "cell_type": "markdown",
            "metadata": [:],
            "source": [
                "# \(project.name)\n",
                "Generated by Pulto\n",
                "Last modified: \(Date().formatted(date: .complete, time: .shortened))\n"
            ]
        ])
    }

    for window in windowManager.getAllWindows() {
        cells.append([
            "cell_type": "code",
            "execution_count": NSNull(),
            "metadata": [
                "window_id": window.id,
                "window_type": window.windowType.rawValue
            ],
            "outputs": [],
            "source": [
                "# Window #\(window.id): \(window.windowType.displayName)\n",
                "# Position: (\(window.position.x), \(window.position.y), \(window.position.z))\n",
                "# Size: \(window.position.width) Ã— \(window.position.height)\n",
                "print(\"Window #\(window.id) - \(window.windowType.displayName)\")\n"
            ]
        ])
    }

    let notebook: [String: Any] = [
        "cells": cells,
        "metadata": [
            "kernelspec": ["display_name":"Python 3","language":"python","name":"python3"],
            "language_info": ["name":"python","version":"3.9.0"]
        ],
        "nbformat": 4,
        "nbformat_minor": 4
    ]

    return (try? JSONSerialization.data(withJSONObject: notebook, options: .prettyPrinted))
        .flatMap { String(data: $0, encoding: .utf8) } ?? "{}"
}

@main
struct EntryPoint: App {
    @StateObject private var windowManager = WindowTypeManager.shared
    @StateObject private var spatialManager = VisionOSSpatialManager.shared
    @StateObject private var entityManager = EntityLifecycleManager.shared
    @Environment(\.openWindow) private var openWindow
    @Environment(\.dismissWindow) private var dismissWindow
    @Environment(\.scenePhase) private var scenePhase

    @StateObject private var notebookManager = NotebookManager(baseURLProvider: {
        UserDefaults.standard.string(forKey: "defaultJupyterURL") ?? "http://127.0.0.1:8888"
    })

    // State to track if we need to restore windows
    @State private var shouldRestoreOnActive = false
    @State private var wasInBackground = false

    // Audio manager for startup sound
    private let audioManager = AudioManager.shared

    // MARK: Scene graph
    @SceneBuilder
    var body: some SwiftUI.Scene {
        mainWindow
        //launcherWindow
        secondaryWindows
        #if os(visionOS)
        volumetricWindows
        immersiveWorkspace
        #endif
    }

    init() {
        setupProjectNotifications()
        setupMainWindowProtection()
        setupAppLifecycleNotifications()
        
        // Play startup sound
        playStartupSound()
    }
    
    private func playStartupSound() {
        // Delay slightly to ensure audio session is ready
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            audioManager.playStartupSound()
        }
    }
    
    // MARK: - 2-D Scenes
    // With spatial management of location of windows for mainWindow scene:
    private var mainWindow: some SwiftUI.Scene {
        WindowGroup(id: "main") {
            MainWindowProtector(windowManager: windowManager)
        }
        .windowStyle(.plain)
        .defaultSize(width: 1_400, height: 900)
        .windowResizability(.contentSize)
        .onChange(of: scenePhase) { oldPhase, newPhase in
            handleScenePhaseChange(from: oldPhase, to: newPhase)
        }
        
    }

    /*
    private var launcherWindow: some SwiftUI.Scene {
        WindowGroup(id: "launcher") {
            LauncherView()
        }
        .windowStyle(.plain)
        .defaultSize(width: 800, height: 600)
    }
    */

    @SceneBuilder
    private var secondaryWindows: some SwiftUI.Scene {
        WindowGroup(for: NewWindowID.ID.self) { $id in
            if let id, let win = windowManager.getWindow(for: id) {
                OpenWindowView(window: win, windowManager: windowManager)   // â† ONLY these 2 args
                    .environmentObject(notebookManager)                     // â† provide env object
                    .environment(\.generateNotebookJSON, { makeNotebookJSON(from: windowManager) })
            } else {
                Text("Window not found")
            }
        }
        WindowGroup(id: "open-project-window") {
            ProjectBrowserView(windowManager: windowManager)
                .environmentObject(windowManager)
        }
        .windowStyle(.plain)
        .defaultSize(width: 1_000, height: 700)
    }

    // MARK: - visionOS-only Scenes
    #if os(visionOS)
    @SceneBuilder
    private var volumetricWindows: some SwiftUI.Scene {
        // Point-cloud volume
        WindowGroup(id: "volumetric-pointcloud", for: Int.self) { $id in
            if
                let id = id,
                let win = windowManager.getWindow(for: id),
                let pointCloudData = win.state.pointCloudData
            {
                PointCloudVolumetricView(
                    windowID: id,
                    pointCloudData: pointCloudData
                )
                .environmentObject(windowManager)
                .environmentObject(entityManager)
                .onAppear {
                    windowManager.markWindowAsOpened(id)
                }
                .onDisappear {
                    windowManager.markWindowAsClosed(id)
                }
            } else {
                EmptyView()
            }
        }
        .windowStyle(.volumetric)
        .defaultSize(width: 0.4, height: 0.4, depth: 0.4, in: .meters)

        // PointCloudDemo dedicated volume
        WindowGroup(id: "volumetric-pointclouddemo", for: Int.self) { $id in
            if let id = id {
                PointCloudPlotView(windowID: id)
                    .environmentObject(windowManager)
                    .environmentObject(entityManager)
                    .onAppear {
                        windowManager.markWindowAsOpened(id)
                    }
                    .onDisappear {
                        windowManager.markWindowAsClosed(id)
                    }
            } else {
                EmptyView()
            }
        }
        .windowStyle(.volumetric)
        .defaultSize(width: 0.6, height: 0.6, depth: 0.6, in: .meters)

        // 3-D model volume
        WindowGroup(id: "volumetric-model3d", for: Int.self) { $id in
            if let id = id, let win = windowManager.getWindow(for: id) {
                if let modelData = win.state.model3DData {
                    // Case 1: We have parsed model data - show the volumetric view
                    Model3DVolumetricView(
                        windowID: id,
                        modelData: modelData
                    )
                    .environmentObject(windowManager)
                    .environmentObject(entityManager)
                    .onAppear {
                        windowManager.markWindowAsOpened(id)
                    }
                    .onDisappear {
                        windowManager.markWindowAsClosed(id)
                    }
                } else if let usdzBookmark = win.state.usdzBookmark {
                    // Case 2: We have a USDZ file bookmark - create a placeholder model and show volumetric view
                    let placeholderModel = Model3DData(
                        title: "USDZ Model",
                        modelType: "usdz",
                        scale: 1.0
                    )
                    Model3DVolumetricView(
                        windowID: id,
                        modelData: placeholderModel
                    )
                    .environmentObject(windowManager)
                    .environmentObject(entityManager)
                    .onAppear {
                        windowManager.markWindowAsOpened(id)
                    }
                    .onDisappear {
                        windowManager.markWindowAsClosed(id)
                    }
                } else {
                    // Case 3: No model data available - show model import interface
                    ModelSelectionView(windowID: id)
                        .environmentObject(windowManager)
                        .environmentObject(entityManager)
                        .onAppear {
                            windowManager.markWindowAsOpened(id)
                        }
                        .onDisappear {
                            windowManager.markWindowAsClosed(id)
                        }
                }
            } else {
                // Error case - show model import interface  
                ModelSelectionView(windowID: 999) // dummy window ID
                    .environmentObject(windowManager)
                    .environmentObject(entityManager)
            }
        }
        .windowStyle(.volumetric)
        .defaultSize(width: 0.5, height: 0.5, depth: 0.5, in: .meters)

        // 3-D chart volume
        WindowGroup(id: "volumetric-chart3d", for: Int.self) { $id in
            if
                let id = id,
                let win = windowManager.getWindow(for: id),
                let chartData = win.state.chart3DData
            {
                Chart3DVolumetricView(
                    windowID: id,
                    chartData: chartData
                )
                .environmentObject(windowManager)
                .environmentObject(entityManager)
                .onAppear {
                    windowManager.markWindowAsOpened(id)
                }
                .onDisappear {
                    windowManager.markWindowAsClosed(id)
                }
            } else {
                EmptyView()
            }
        }
        .windowStyle(.volumetric)
        .defaultSize(width: 0.4, height: 0.4, depth: 0.4, in: .meters)
    }

    private var immersiveWorkspace: some SwiftUI.Scene {
        ImmersiveSpace(id: "immersive-workspace") {
            ImmersiveWorkspaceView()
                .environmentObject(windowManager)
                .environmentObject(entityManager)
        }
        .immersionStyle(selection: .constant(.mixed), in: .mixed)
    }
    #endif

    // MARK: - App Lifecycle Management
    private func handleScenePhaseChange(from oldPhase: ScenePhase, to newPhase: ScenePhase) {
        print("ðŸ”„ Scene phase changed from \(oldPhase) to \(newPhase)")
        
        switch newPhase {
        case .background:
            handleAppEnteringBackground()
        case .active:
            if wasInBackground {
                handleAppBecomingActive()
            }
        case .inactive:
            // App is becoming inactive but not necessarily backgrounded yet
            break
        @unknown default:
            break
        }
    }
    
    private func handleAppEnteringBackground() {
        print("ðŸ“± App entering background - closing all windows")
        wasInBackground = true
        shouldRestoreOnActive = true
        
        // Close all volumetric and secondary windows
        Task { @MainActor in
            closeAllNonMainWindows()
            
            // Clean up entities
            EntityLifecycleManager.shared.performEmergencyCleanup()
            
            // Post notification for other components
            NotificationCenter.default.post(name: .appWillEnterBackground, object: nil)
        }
    }
    
    private func handleAppBecomingActive() {
        print("ðŸš€ App becoming active - restoring main window")
        wasInBackground = false
        
        Task { @MainActor in
            // Ensure main window is visible
            openWindow(id: "main")
            
            // If there was a selected project, recreate demo windows after a delay
            if shouldRestoreOnActive && windowManager.selectedProject != nil {
                DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                    self.createDemo3DWindowForProject()
                }
            }
            
            shouldRestoreOnActive = false
            
            // Post notification for other components
            NotificationCenter.default.post(name: .appDidBecomeActive, object: nil)
        }
    }
    
    @MainActor
    private func closeAllNonMainWindows() {
        // Get all open windows except main
        let openWindows = windowManager.getAllWindows(onlyOpen: true)
        
        for window in openWindows {
            windowManager.markWindowAsClosed(window.id)
        }
        
        // Clean up the window manager
        windowManager.cleanupClosedWindows()
        
        print("ðŸ—‘ï¸ Closed \(openWindows.count) non-main windows")
    }

    // MARK: - App Lifecycle Notification Setup
    private func setupAppLifecycleNotifications() {
        // Listen for manual app lifecycle events if needed
        NotificationCenter.default.addObserver(
            forName: .appWillEnterBackground,
            object: nil,
            queue: .main
        ) { _ in
            print("ðŸ“± Received manual background notification")
        }
        
        NotificationCenter.default.addObserver(
            forName: .appDidBecomeActive,
            object: nil,
            queue: .main
        ) { _ in
            print("ðŸš€ Received manual active notification")
        }
    }

    // MARK: - Project Notification Setup
    private func setupProjectNotifications() {
        // Listen for project selection notifications
        NotificationCenter.default.addObserver(
            forName: .projectSelected,
            object: nil,
            queue: .main
        ) { notification in
            // Use explicit type to resolve ambiguity
            if let project = notification.object as? Project {
                // Create 3D content when a project is selected
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                    Task { @MainActor in
                        _ = WindowTypeManager.shared
                        self.createDemo3DWindowForProject()
                    }
                }
            }
        }

        // Listen for project cleared notifications
        NotificationCenter.default.addObserver(
            forName: .projectCleared,
            object: nil,
            queue: .main
        ) { _ in
            // Optionally clean up project-specific windows
            Task { @MainActor in
                WindowTypeManager.shared.cleanupClosedWindows()
            }
        }
    }
    
    // MARK: - Main Window Protection
    private func setupMainWindowProtection() {
        // Listen for main window reopen requests
        NotificationCenter.default.addObserver(
            forName: .reopenMainWindow,
            object: nil,
            queue: .main
        ) { _ in
            Task { @MainActor in
                // Reopen the main window
                self.openWindow(id: "main")
                print("ðŸ”„ Automatically reopened main window")
            }
        }
    }

    // MARK: - Project-Based Window Creation
    @MainActor
    private func createDemo3DWindowForProject() {
        // Only create 3D demo windows if there's an active project
        guard let selectedProject = windowManager.selectedProject else {
            print("No project selected - skipping 3D demo window creation")
            return
        }

        print("ðŸŽ¯ Creating demo 3D windows for project: \(selectedProject.name)")
        createDemo3DWindow()
    }

    // MARK: - Demo 3D Window Creation
    @MainActor
    private func createDemo3DWindow() {
        // Create a 3D model window
        let modelWindowID = windowManager.getNextWindowID()
        let modelPosition = WindowPosition(x: -200, y: 0, z: -100, width: 800, height: 600)
        let modelWindow = windowManager.createWindow(.model3d, id: modelWindowID, position: modelPosition)

        // Try to load the Pulto USDZ file first, fallback to demo cube
        if let pultoModel = loadPultoUSDZModel() {
            windowManager.updateWindowModel3DData(modelWindowID, model3DData: pultoModel)
            windowManager.updateWindowContent(modelWindowID, content: "Pulto USDZ model - loaded for project: \(windowManager.selectedProject?.name ?? "Unknown")")
            windowManager.addWindowTag(modelWindowID, tag: "Pulto-USDZ")
        } else {
            // Create a demo cube as fallback
            let demoCube = Model3DData.generateCube(size: 2.0)
            windowManager.updateWindowModel3DData(modelWindowID, model3DData: demoCube)
            windowManager.updateWindowContent(modelWindowID, content: "Demo 3D cube - created for project: \(windowManager.selectedProject?.name ?? "Unknown")")
            windowManager.addWindowTag(modelWindowID, tag: "Demo")
        }

        // Create a 3D chart window
        let chartWindowID = windowManager.getNextWindowID()
        let chartPosition = WindowPosition(x: 200, y: 0, z: -100, width: 800, height: 600)
        _ = windowManager.createWindow(.charts, id: chartWindowID, position: chartPosition)

        // Create demo 3D chart data
        let demo3DChart = Chart3DData.generateWave()
        windowManager.updateWindowChart3DData(chartWindowID, chart3DData: demo3DChart)
        windowManager.updateWindowContent(chartWindowID, content: "Demo 3D wave chart - created for project: \(windowManager.selectedProject?.name ?? "Unknown")")
        windowManager.addWindowTag(chartWindowID, tag: "Demo-Chart3D")

        // Create a PointCloudDemo window
        let pointCloudDemoWindowID = windowManager.getNextWindowID()
        let pointCloudDemoPosition = WindowPosition(x: 0, y: 150, z: -100, width: 800, height: 600)
        _ = windowManager.createWindow(.pointcloud, id: pointCloudDemoWindowID, position: pointCloudDemoPosition)

        // Create demo point cloud data
        let demoPointCloud = PointCloudDemo.generateSpherePointCloudData(radius: 5.0, points: 500)
        windowManager.updateWindowPointCloud(pointCloudDemoWindowID, pointCloud: demoPointCloud)
        windowManager.updateWindowContent(pointCloudDemoWindowID, content: "Demo Point Cloud - created for project: \(windowManager.selectedProject?.name ?? "Unknown")")
        windowManager.addWindowTag(pointCloudDemoWindowID, tag: "Demo-PointCloud")

        print("ðŸ“Š Created demo windows: Model(#\(modelWindowID)), Chart(#\(chartWindowID)), PointCloud(#\(pointCloudDemoWindowID))")

        // Open the volumetric windows
        #if os(visionOS)
        openWindow(id: "volumetric-model3d", value: modelWindowID)
        print("ðŸªŸ Opened volumetric-model3d with ID: \(modelWindowID)")

        // Delay the chart window slightly so they don't overlap
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            openWindow(id: "volumetric-chart3d", value: chartWindowID)
            print("ðŸªŸ Opened volumetric-chart3d with ID: \(chartWindowID)")
        }

        // Delay the point cloud demo window a bit more
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            openWindow(id: "volumetric-pointclouddemo", value: pointCloudDemoWindowID)
            print("ðŸªŸ Opened volumetric-pointclouddemo with ID: \(pointCloudDemoWindowID)")
        }
        #endif
    }

    private func loadPultoUSDZModel() -> Model3DData? {
        // Try to find and load the Pulto USDZ file
        guard let bundlePath = Bundle.main.path(forResource: "Pluto_1_2374", ofType: "usdz") else {
            print("Pulto USDZ file not found in bundle")
            return nil
        }

        _ = URL(fileURLWithPath: bundlePath)

        do {
            let fileSize = try FileManager.default.attributesOfItem(atPath: bundlePath)[.size] as? Int64 ?? 0
            print("Found Pulto USDZ file: \(bundlePath) (\(fileSize) bytes)")

            // Create a model representation for the USDZ file
            // Since we can't directly parse USDZ, we'll create a placeholder that represents it
            var model = Model3DData(title: "Pulto Model", modelType: "usdz")

            // Create a sophisticated sphere to represent the Pulto planet
            let radius = 2.0
            let segments = 32 // High detail for the planet

            // Generate vertices for a detailed sphere
            for i in 0...segments {
                let phi = Double(i) * .pi / Double(segments)
                for j in 0..<(segments * 2) {
                    let theta = Double(j) * 2.0 * .pi / Double(segments * 2)

                    // Add some surface variation to make it more planet-like
                    let variation = 0.1 * sin(phi * 3) * cos(theta * 4)
                    let actualRadius = radius + variation

                    let x = actualRadius * sin(phi) * cos(theta)
                    let y = actualRadius * cos(phi)
                    let z = actualRadius * sin(phi) * sin(theta)

                    model.vertices.append(Model3DData.Vertex3D(x: x, y: y, z: z))
                }
            }

            // Generate faces for the sphere
            for i in 0..<segments {
                for j in 0..<(segments * 2) {
                    let current = i * (segments * 2) + j
                    let next = i * (segments * 2) + (j + 1) % (segments * 2)
                    let currentNext = (i + 1) * (segments * 2) + j
                    let nextNext = (i + 1) * (segments * 2) + (j + 1) % (segments * 2)

                    if i < segments {
                        // Create triangular faces for better detail
                        model.faces.append(Model3DData.Face3D(vertices: [current, next, nextNext], materialIndex: 0))
                        model.faces.append(Model3DData.Face3D(vertices: [current, nextNext, currentNext], materialIndex: 0))
                    }
                }
            }

            // Create materials that represent Pulto's appearance
            model.materials = [
                Model3DData.Material3D(
                    name: "pulto_surface",
                    color: "teal",
                    metallic: 0.3,
                    roughness: 0.7,
                    transparency: 0.0
                )
            ]

            return model

        } catch {
            print("Error accessing Pulto USDZ file: \(error)")
            return nil
        }
    }

    // MARK: - Shared-file handler
    private func handleSharedURL(_ url: URL) {
        guard url.pathExtension.lowercased() == "csv" else { return }

        Task {
            do {
                let text = try String(contentsOf: url)
                guard let csv = CSVParser.parse(text) else { return }

                let dtypes = Dictionary(uniqueKeysWithValues: zip(
                    csv.headers,
                    csv.columnTypes.map { type -> String in
                        switch type {
                        case .numeric:     return "float"
                        case .categorical: return "string"
                        case .date:        return "string"
                        case .unknown:     return "string"
                        }
                    }
                ))

                let frame = DataFrameData(
                    columns: csv.headers,
                    rows:    csv.rows,
                    dtypes:  dtypes
                )

                let id  = windowManager.getNextWindowID()
                let win = windowManager.createWindow(.column, id: id)
                windowManager.updateWindowDataFrame(win.id, dataFrame: frame)
                windowManager.markWindowAsOpened(win.id)

            } catch {
                print("Error importing shared CSV: \(error)")
            }
        }
    }
}

// MARK: - Main Window Protector
struct MainWindowProtector: View {
    @ObservedObject var windowManager: WindowTypeManager
    @StateObject private var spatialManager = VisionOSSpatialManager.shared
    @StateObject private var entityManager = EntityLifecycleManager.shared
    @Environment(\.dismissWindow) private var dismissWindow
    @Environment(\.openWindow) private var openWindow
    @Environment(\.scenePhase) private var scenePhase
    @State private var shouldPreventClose = true
    
    var body: some View {
        ProjectAwareEnvironmentView(windowManager: windowManager)
            .environmentObject(windowManager)
            .environmentObject(spatialManager)
            .environmentObject(entityManager)
            .onAppear {
                print("âœ… Main EnvironmentView window opened")
                shouldPreventClose = true
                Task { @MainActor in
                    EntityLifecycleManager.shared.registerEntity(Entity(), for: -1)
                }
            }
            .onDisappear {
                // Only prevent closure if the app is active and we're not intentionally backgrounding
                if shouldPreventClose && scenePhase == .active {
                    print("ðŸš« Preventing main window closure - reopening")
                    // Reopen immediately
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                        openWindow(id: "main")
                    }
                } else {
                    print("âœ… Allowing main window closure (app backgrounding or inactive)")
                }
                Task { @MainActor in
                    EntityLifecycleManager.shared.cleanupWindow(-1)
                }
            }
            .onChange(of: scenePhase) { _, newPhase in
                // Allow closure when app is backgrounding or becoming inactive
                shouldPreventClose = (newPhase == .active)
            }
    }
}

// MARK: - Project-Aware Environment View
struct ProjectAwareEnvironmentView: View {
    @ObservedObject var windowManager: WindowTypeManager
    @Environment(\.openWindow) private var openWindow

    var body: some View {
        // Use the updated EnvironmentView we've been working on
        EnvironmentView()
            .environment(\.generateNotebookJSON, { makeNotebookJSON(from: windowManager) }) // for juypter kit
            .environmentObject(windowManager)
            .onOpenURL(perform: handleSharedURL(_:))
            .onReceive(NotificationCenter.default.publisher(for: .projectSelected)) { notification in
                if let project = notification.object as? Project {
                    // Create 3D content when a project is selected
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                        createDemo3DWindowForProject()
                    }
                }
            }
            .onReceive(NotificationCenter.default.publisher(for: .projectCleared)) { _ in
                // Clean up project-specific windows
                windowManager.cleanupClosedWindows()
                // Also trigger full entity cleanup
                Task { @MainActor in
                    EntityLifecycleManager.shared.performEmergencyCleanup()
                }
            }
            .onReceive(NotificationCenter.default.publisher(for: .appDidBecomeActive)) { _ in
                // Handle app becoming active - ensure main window is visible
                print("ðŸš€ EnvironmentView received app active notification")
            }
    }

    private func createDemo3DWindowForProject() {
        // Only create 3D demo windows if there's an active project
        guard windowManager.selectedProject != nil else {
            print("No project selected - skipping 3D demo window creation")
            return
        }

        // Create a 3D model window
        let modelWindowID = windowManager.getNextWindowID()
        let modelPosition = WindowPosition(x: -200, y: 0, z: -100, width: 800, height: 600)
        let modelWindow = windowManager.createWindow(.model3d, id: modelWindowID, position: modelPosition)

        // Try to load the Pulto USDZ file first, fallback to demo cube
        if let pultoModel = loadPultoUSDZModel() {
            windowManager.updateWindowModel3DData(modelWindowID, model3DData: pultoModel)
            windowManager.updateWindowContent(modelWindowID, content: "Pulto USDZ model - loaded for project: \(windowManager.selectedProject?.name ?? "Unknown")")
            windowManager.addWindowTag(modelWindowID, tag: "Pulto-USDZ")
        } else {
            // Create a demo cube as fallback
            let demoCube = Model3DData.generateCube(size: 2.0)
            windowManager.updateWindowModel3DData(modelWindowID, model3DData: demoCube)
            windowManager.updateWindowContent(modelWindowID, content: "Demo 3D cube - created for project: \(windowManager.selectedProject?.name ?? "Unknown")")
            windowManager.addWindowTag(modelWindowID, tag: "Demo")
        }

        // Create a 3D chart window
        let chartWindowID = windowManager.getNextWindowID()
        let chartPosition = WindowPosition(x: 200, y: 0, z: -100, width: 800, height: 600)
        _ = windowManager.createWindow(.charts, id: chartWindowID, position: chartPosition)

        // Create demo 3D chart data
        let demo3DChart = Chart3DData.generateWave()
        windowManager.updateWindowChart3DData(chartWindowID, chart3DData: demo3DChart)
        windowManager.updateWindowContent(chartWindowID, content: "Demo 3D wave chart - created for project: \(windowManager.selectedProject?.name ?? "Unknown")")
        windowManager.addWindowTag(chartWindowID, tag: "Demo-Chart3D")

        // Create a PointCloudDemo window
        let pointCloudDemoWindowID = windowManager.getNextWindowID()
        let pointCloudDemoPosition = WindowPosition(x: 0, y: 150, z: -100, width: 800, height: 600)
        _ = windowManager.createWindow(.pointcloud, id: pointCloudDemoWindowID, position: pointCloudDemoPosition)

        // Create demo point cloud data
        let demoPointCloud = PointCloudDemo.generateSpherePointCloudData(radius: 5.0, points: 500)
        windowManager.updateWindowPointCloud(pointCloudDemoWindowID, pointCloud: demoPointCloud)
        windowManager.updateWindowContent(pointCloudDemoWindowID, content: "Demo Point Cloud - created for project: \(windowManager.selectedProject?.name ?? "Unknown")")
        windowManager.addWindowTag(pointCloudDemoWindowID, tag: "Demo-PointCloud")

        // Open the volumetric windows
        #if os(visionOS)
        openWindow(id: "volumetric-model3d", value: modelWindowID)

        // Delay the chart window slightly so they don't overlap
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            openWindow(id: "volumetric-chart3d", value: chartWindowID)
        }

        // Delay the point cloud demo window a bit more
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            openWindow(id: "volumetric-pointclouddemo", value: pointCloudDemoWindowID)
        }
        #endif
    }

    private func loadPultoUSDZModel() -> Model3DData? {
        // Try to find and load the Pulto USDZ file
        guard let bundlePath = Bundle.main.path(forResource: "Pluto_1_2374", ofType: "usdz") else {
            print("Pulto USDZ file not found in bundle")
            return nil
        }

        _ = URL(fileURLWithPath: bundlePath)

        do {
            let fileSize = try FileManager.default.attributesOfItem(atPath: bundlePath)[.size] as? Int64 ?? 0
            print("Found Pulto USDZ file: \(bundlePath) (\(fileSize) bytes)")

            // Create a model representation for the USDZ file
            // Since we can't directly parse USDZ, we'll create a placeholder that represents it
            var model = Model3DData(title: "Pulto Model", modelType: "usdz")

            // Create a sophisticated sphere to represent the Pulto planet
            let radius = 2.0
            let segments = 32 // High detail for the planet

            // Generate vertices for a detailed sphere
            for i in 0...segments {
                let phi = Double(i) * .pi / Double(segments)
                for j in 0..<(segments * 2) {
                    let theta = Double(j) * 2.0 * .pi / Double(segments * 2)

                    // Add some surface variation to make it more planet-like
                    let variation = 0.1 * sin(phi * 3) * cos(theta * 4)
                    let actualRadius = radius + variation

                    let x = actualRadius * sin(phi) * cos(theta)
                    let y = actualRadius * cos(phi)
                    let z = actualRadius * sin(phi) * sin(theta)

                    model.vertices.append(Model3DData.Vertex3D(x: x, y: y, z: z))
                }
            }

            // Generate faces for the sphere
            for i in 0..<segments {
                for j in 0..<(segments * 2) {
                    let current = i * (segments * 2) + j
                    let next = i * (segments * 2) + (j + 1) % (segments * 2)
                    let currentNext = (i + 1) * (segments * 2) + j
                    let nextNext = (i + 1) * (segments * 2) + (j + 1) % (segments * 2)

                    if i < segments {
                        // Create triangular faces for better detail
                        model.faces.append(Model3DData.Face3D(vertices: [current, next, nextNext], materialIndex: 0))
                        model.faces.append(Model3DData.Face3D(vertices: [current, nextNext, currentNext], materialIndex: 0))
                    }
                }
            }

            // Create materials that represent Pulto's appearance
            model.materials = [
                Model3DData.Material3D(
                    name: "pulto_surface",
                    color: "teal",
                    metallic: 0.3,
                    roughness: 0.7,
                    transparency: 0.0
                )
            ]

            return model

        } catch {
            print("Error accessing Pulto USDZ file: \(error)")
            return nil
        }
    }

    private func handleSharedURL(_ url: URL) {
        guard url.pathExtension.lowercased() == "csv" else { return }

        Task {
            do {
                let text = try String(contentsOf: url)
                guard let csv = CSVParser.parse(text) else { return }

                let dtypes = Dictionary(uniqueKeysWithValues: zip(
                    csv.headers,
                    csv.columnTypes.map { type -> String in
                        switch type {
                        case .numeric:     return "float"
                        case .categorical: return "string"
                        case .date:        return "string"
                        case .unknown:     return "string"
                        }
                    }
                ))

                let frame = DataFrameData(
                    columns: csv.headers,
                    rows:    csv.rows,
                    dtypes:  dtypes
                )

                let id  = windowManager.getNextWindowID()
                let win = windowManager.createWindow(.column, id: id)
                windowManager.updateWindowDataFrame(win.id, dataFrame: frame)
                windowManager.markWindowAsOpened(win.id)

            } catch {
                print("Error importing shared CSV: \(error)")
            }
        }
    }
}
