//
//  JupyterNotebook.swift
//  Pulto3
//
//  Created by Joshua Herman on 7/19/25.
//  Copyright Â© 2025 Apple. All rights reserved.
//
/*
import Foundation
import SwiftUI

// MARK: - Jupyter Notebook Format Structures

struct JupyterNotebookImport: Codable {
    var cells: [JupyterCell]
    var metadata: JupyterMetadata
    var nbformat: Int
    var nbformat_minor: Int
    
    init() {
        self.cells = []
        self.metadata = JupyterMetadata()
        self.nbformat = 4
        self.nbformat_minor = 2
    }
}

struct JupyterCell: Codable {
    var cell_type: String
    var metadata: CellMetadata
    var source: [String]
    var outputs: [JupyterOutput]?
    var execution_count: Int?
    
    init(type: String, source: [String]) {
        self.cell_type = type
        self.metadata = CellMetadata()
        self.source = source
        self.outputs = type == "code" ? [] : nil
        self.execution_count = type == "code" ? 1 : nil
    }
}

struct CellMetadata: Codable {
    var collapsed: Bool?
    var scrolled: Bool?
    var tags: [String]?
    var spatialData: SpatialCellData?
    
    init() {
        self.collapsed = false
        self.scrolled = false
        self.tags = []
        self.spatialData = nil
    }
}

struct SpatialCellData: Codable {
    var position: SpatialPosition
    var visualizationType: String
    var volumetricData: VolumetricData?
    
    struct SpatialPosition: Codable {
        var x: Double
        var y: Double
        var z: Double
        var rotationX: Double
        var rotationY: Double
        var rotationZ: Double
    }
    
    struct VolumetricData: Codable {
        var width: Double
        var height: Double
        var depth: Double
        var modelURL: String?
        var pointCloudData: String? // Base64 encoded
    }
}

struct JupyterOutput: Codable {
    var output_type: String
    var data: OutputData?
    var text: [String]?
    var name: String?
    var execution_count: Int?
    
    struct OutputData: Codable {
        var text_plain: [String]?
        var image_png: String?
        var image_svg: String?
        var application_json: AnyCodable?
        var spatial_volumetric: SpatialVolumetricOutput?
        
        enum CodingKeys: String, CodingKey {
            case text_plain = "text/plain"
            case image_png = "image/png"
            case image_svg = "image/svg+xml"
            case application_json = "application/json"
            case spatial_volumetric = "application/vnd.pulto.spatial+json"
        }
    }
}

struct SpatialVolumetricOutput: Codable {
    var type: String // "pointcloud", "model3d", "volumetric"
    var data: String // Base64 encoded data
    var metadata: [String: AnyCodable]
}

struct JupyterMetadata: Codable {
    var kernelspec: KernelSpec?
    var language_info: LanguageInfo?
    var spatialVisualization: SpatialVisualizationMetadata?
    
    init() {
        self.kernelspec = KernelSpec()
        self.language_info = LanguageInfo()
        self.spatialVisualization = nil
    }
}

struct KernelSpec: Codable {
    var display_name: String
    var language: String
    var name: String
    
    init() {
        self.display_name = "Python 3"
        self.language = "python"
        self.name = "python3"
    }
}

struct LanguageInfo: Codable {
    var name: String
    var version: String
    
    init() {
        self.name = "python"
        self.version = "3.9.0"
    }
}

struct SpatialVisualizationMetadata: Codable {
    var enabled: Bool
    var defaultVisualizationType: String
    var volumetricSettings: VolumetricSettings
    
    struct VolumetricSettings: Codable {
        var defaultScale: Double
        var enableInteraction: Bool
        var renderQuality: String // "low", "medium", "high"
    }
}

// MARK: - Notebook Serializer

class NotebookSerializer {
    
    // MARK: - Create Spatial Notebook
    
    static func createSpatialNotebook(from analysisResults: [FileAnalysisResult]) -> JupyterNotebook {
        var notebook = JupyterNotebook()
        
        // Add metadata
        notebook.metadata.spatialVisualization = SpatialVisualizationMetadata(
            enabled: true,
            defaultVisualizationType: "auto",
            volumetricSettings: .init(
                defaultScale: 1.0,
                enableInteraction: true,
                renderQuality: "high"
            )
        )
        
        // Add header cell
        let headerCell = JupyterCell(
            type: "markdown",
            source: [
                "# Spatial Data Visualization Notebook\n",
                "Generated by Pulto Spatial Data System\n",
                "\n",
                "This notebook contains spatial visualizations of your data files."
            ]
        )
        notebook.cells.append(headerCell)
        
        // Add cells for each analysis result
        for (index, result) in analysisResults.enumerated() {
            let cells = createCellsForResult(result, index: index)
            notebook.cells.append(contentsOf: cells)
        }
        
        return notebook
    }
    
    static func createCellsForResult(_ result: FileAnalysisResult, index: Int) -> [JupyterCell] {
        var cells: [JupyterCell] = []
        
        // Add markdown header
        let headerCell = JupyterCell(
            type: "markdown",
            source: ["## \(result.fileName)"]
        )
        cells.append(headerCell)
        
        // Add code cell based on visualization type
        switch result.visualizationType {
        case .dataTable:
            cells.append(createDataTableCell(for: result))
            
        case .chart2D(let recommendation):
            cells.append(createChart2DCell(for: result, recommendation: recommendation))
            
        case .pointCloud3D:
            cells.append(createPointCloud3DCell(for: result))
            
        case .volumetric3D:
            cells.append(createVolumetric3DCell(for: result))
            
        case .notebook:
            cells.append(createNotebookReferenceCell(for: result))
            
        case .unknown:
            cells.append(createUnknownTypeCell(for: result))
        }
        
        return cells
    }
    
    // MARK: - Cell Creation Methods
    
    static func createDataTableCell(for result: FileAnalysisResult) -> JupyterCell {
        var cell = JupyterCell(
            type: "code",
            source: [
                "import pandas as pd\n",
                "import matplotlib.pyplot as plt\n",
                "\n",
                "# Load data from file\n",
                "df = pd.read_csv('\(result.fileName)')\n",
                "print(f\"Data shape: {df.shape}\")\n",
                "print(f\"Columns: {list(df.columns)}\")\n",
                "\n",
                "# Display first few rows\n",
                "df.head()"
            ]
        )
        
        // Add spatial metadata
        cell.metadata.spatialData = SpatialCellData(
            position: .init(x: 0, y: Double(result.hashValue % 10) * 0.5, z: 0, rotationX: 0, rotationY: 0, rotationZ: 0),
            visualizationType: "dataTable",
            volumetricData: nil
        )
        
        return cell
    }
    
    static func createChart2DCell(for result: FileAnalysisResult, recommendation: ChartRecommendation) -> JupyterCell {
        let chartCode = generateChartCode(for: recommendation, fileName: result.fileName)
        
        var cell = JupyterCell(
            type: "code",
            source: chartCode.components(separatedBy: "\n")
        )
        
        cell.metadata.spatialData = SpatialCellData(
            position: .init(x: 1, y: Double(result.hashValue % 10) * 0.5, z: 0, rotationX: 0, rotationY: 0, rotationZ: 0),
            visualizationType: "chart2D",
            volumetricData: nil
        )
        
        return cell
    }
    
    static func createPointCloud3DCell(for result: FileAnalysisResult) -> JupyterCell {
        var cell = JupyterCell(
            type: "code",
            source: [
                "import numpy as np\n",
                "import plotly.graph_objects as go\n",
                "\n",
                "# Load point cloud data\n",
                "# Assuming the file contains x, y, z coordinates\n",
                "data = np.loadtxt('\(result.fileName)', delimiter=',')\n",
                "\n",
                "# Create 3D scatter plot\n",
                "fig = go.Figure(data=[go.Scatter3d(\n",
                "    x=data[:, 0],\n",
                "    y=data[:, 1],\n",
                "    z=data[:, 2],\n",
                "    mode='markers',\n",
                "    marker=dict(\n",
                "        size=2,\n",
                "        color=data[:, 2],\n",
                "        colorscale='Viridis',\n",
                "        showscale=True\n",
                "    )\n",
                ")])\n",
                "\n",
                "fig.update_layout(\n",
                "    title='Point Cloud Visualization',\n",
                "    scene=dict(\n",
                "        xaxis_title='X',\n",
                "        yaxis_title='Y',\n",
                "        zaxis_title='Z'\n",
                "    )\n",
                ")\n",
                "\n",
                "# Add spatial metadata for volumetric rendering\n",
                "fig.show()\n",
                "\n",
                "# Export for spatial visualization\n",
                "print(f\"Point cloud contains {len(data)} points\")"
            ]
        )
        
        cell.metadata.spatialData = SpatialCellData(
            position: .init(x: 0, y: 0, z: 1, rotationX: 0, rotationY: 0, rotationZ: 0),
            visualizationType: "pointCloud3D",
            volumetricData: .init(
                width: 1.0,
                height: 1.0,
                depth: 1.0,
                modelURL: nil,
                pointCloudData: nil // Would be filled with actual data
            )
        )
        
        return cell
    }
    
    static func createVolumetric3DCell(for result: FileAnalysisResult) -> JupyterCell {
        var cell = JupyterCell(
            type: "code",
            source: [
                "# 3D Model Visualization\n",
                "# This cell references a 3D model file for volumetric display\n",
                "\n",
                "model_info = {\n",
                "    'file': '\(result.fileName)',\n",
                "    'type': '\(result.fileType)',\n",
                "    'volumetric': True\n",
                "}\n",
                "\n",
                "print(f\"3D Model: {model_info['file']}\")\n",
                "print(f\"Format: {model_info['type']}\")\n",
                "print(\"Ready for volumetric rendering\")"
            ]
        )
        
        cell.metadata.spatialData = SpatialCellData(
            position: .init(x: -1, y: 0, z: 0, rotationX: 0, rotationY: 45, rotationZ: 0),
            visualizationType: "volumetric3D",
            volumetricData: .init(
                width: 1.0,
                height: 1.0,
                depth: 1.0,
                modelURL: result.fileURL.absoluteString,
                pointCloudData: nil
            )
        )
        
        // Add custom output
        let spatialOutput = JupyterOutput(
            output_type: "display_data",
            data: .init(
                text_plain: ["3D Model loaded"],
                image_png: nil,
                image_svg: nil,
                application_json: nil,
                spatial_volumetric: SpatialVolumetricOutput(
                    type: "model3d",
                    data: "", // Would contain base64 encoded model data
                    metadata: ["format": AnyCodable(result.fileType)]
                )
            ),
            text: nil,
            name: nil,
            execution_count: nil
        )
        
        cell.outputs = [spatialOutput]
        
        return cell
    }
    
    static func createNotebookReferenceCell(for result: FileAnalysisResult) -> JupyterCell {
        return JupyterCell(
            type: "markdown",
            source: [
                "### Embedded Notebook\n",
                "This references another Jupyter notebook: `\(result.fileName)`\n",
                "\n",
                "The notebook can be loaded and its visualizations integrated into the spatial environment."
            ]
        )
    }
    
    static func createUnknownTypeCell(for result: FileAnalysisResult) -> JupyterCell {
        return JupyterCell(
            type: "markdown",
            source: [
                "### Unknown File Type\n",
                "File: `\(result.fileName)`\n",
                "Type: `\(result.fileType)`\n",
                "\n",
                "This file type is not currently supported for automatic visualization."
            ]
        )
    }
    
    // MARK: - Chart Code Generation
    
    static func generateChartCode(for recommendation: ChartRecommendation, fileName: String) -> String {
        switch recommendation {
        case .lineChart:
            return """
            import pandas as pd
            import matplotlib.pyplot as plt
            
            df = pd.read_csv('\(fileName)')
            
            # Assuming first column is x, second is y
            plt.figure(figsize=(10, 6))
            plt.plot(df.iloc[:, 0], df.iloc[:, 1], marker='o')
            plt.xlabel(df.columns[0])
            plt.ylabel(df.columns[1])
            plt.title('Line Chart')
            plt.grid(True, alpha=0.3)
            plt.show()
            """
            
        case .barChart:
            return """
            import pandas as pd
            import matplotlib.pyplot as plt
            
            df = pd.read_csv('\(fileName)')
            
            plt.figure(figsize=(10, 6))
            plt.bar(range(len(df)), df.iloc[:, 1])
            plt.xlabel('Index')
            plt.ylabel(df.columns[1])
            plt.title('Bar Chart')
            plt.grid(True, alpha=0.3)
            plt.show()
            """
            
        case .scatterPlot:
            return """
            import pandas as pd
            import matplotlib.pyplot as plt
            
            df = pd.read_csv('\(fileName)')
            
            plt.figure(figsize=(10, 6))
            plt.scatter(df.iloc[:, 0], df.iloc[:, 1], alpha=0.6)
            plt.xlabel(df.columns[0])
            plt.ylabel(df.columns[1])
            plt.title('Scatter Plot')
            plt.grid(True, alpha=0.3)
            plt.show()
            """
            
        case .pieChart:
            return """
            import pandas as pd
            import matplotlib.pyplot as plt
            
            df = pd.read_csv('\(fileName)')
            
            # Aggregate data for pie chart
            value_counts = df.iloc[:, 0].value_counts()
            
            plt.figure(figsize=(10, 8))
            plt.pie(value_counts.values, labels=value_counts.index, autopct='%1.1f%%')
            plt.title('Pie Chart')
            plt.show()
            """
            
        case .areaChart:
            return """
            import pandas as pd
            import matplotlib.pyplot as plt
            
            df = pd.read_csv('\(fileName)')
            
            plt.figure(figsize=(10, 6))
            plt.fill_between(range(len(df)), df.iloc[:, 1], alpha=0.5)
            plt.plot(range(len(df)), df.iloc[:, 1])
            plt.xlabel('Index')
            plt.ylabel(df.columns[1])
            plt.title('Area Chart')
            plt.grid(True, alpha=0.3)
            plt.show()
            """
            
        case .histogram:
            return """
            import pandas as pd
            import matplotlib.pyplot as plt
            
            df = pd.read_csv('\(fileName)')
            
            plt.figure(figsize=(10, 6))
            plt.hist(df.iloc[:, 1], bins=30, edgecolor='black', alpha=0.7)
            plt.xlabel(df.columns[1])
            plt.ylabel('Frequency')
            plt.title('Histogram')
            plt.grid(True, alpha=0.3)
            plt.show()
            """
        }
    }
    
    // MARK: - Save and Load Methods
    
    static func saveNotebook(_ notebook: JupyterNotebook, to url: URL) throws {
        let encoder = JSONEncoder()
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
        let data = try encoder.encode(notebook)
        try data.write(to: url)
    }
    
    static func loadNotebook(from url: URL) throws -> JupyterNotebook {
        let data = try Data(contentsOf: url)
        let decoder = JSONDecoder()
        return try decoder.decode(JupyterNotebook.self, from: data)
    }
    
    // MARK: - Export Spatial Visualization Data
    
    static func exportSpatialVisualizationData(from notebook: JupyterNotebook) -> [SpatialVisualizationData] {
        var visualizations: [SpatialVisualizationData] = []
        
        for (index, cell) in notebook.cells.enumerated() {
            if let spatialData = cell.metadata.spatialData {
                let vizData = SpatialVisualizationData(
                    cellIndex: index,
                    type: spatialData.visualizationType,
                    position: SIMD3<Float>(
                        Float(spatialData.position.x),
                        Float(spatialData.position.y),
                        Float(spatialData.position.z)
                    ),
                    rotation: SIMD3<Float>(
                        Float(spatialData.position.rotationX),
                        Float(spatialData.position.rotationY),
                        Float(spatialData.position.rotationZ)
                    ),
                    volumetricData: spatialData.volumetricData
                )
                visualizations.append(vizData)
            }
        }
        
        return visualizations
    }
}

// MARK: - Supporting Types

struct SpatialVisualizationData {
    let cellIndex: Int
    let type: String
    let position: SIMD3<Float>
    let rotation: SIMD3<Float>
    let volumetricData: SpatialCellData.VolumetricData?
}

// MARK: - AnyCodable for flexible JSON encoding/decoding

struct AnyCodable: Codable {
    let value: Any
    
    init(_ value: Any) {
        self.value = value
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        
        if let bool = try? container.decode(Bool.self) {
            value = bool
        } else if let int = try? container.decode(Int.self) {
            value = int
        } else if let double = try? container.decode(Double.self) {
            value = double
        } else if let string = try? container.decode(String.self) {
            value = string
        } else if let array = try? container.decode([AnyCodable].self) {
            value = array.map { $0.value }
        } else if let dictionary = try? container.decode([String: AnyCodable].self) {
            value = dictionary.mapValues { $0.value }
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Cannot decode value")
        }
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        
        switch value {
        case let bool as Bool:
            try container.encode(bool)
        case let int as Int:
            try container.encode(int)
        case let double as Double:
            try container.encode(double)
        case let string as String:
            try container.encode(string)
        case let array as [Any]:
            try container.encode(array.map { AnyCodable($0) })
        case let dictionary as [String: Any]:
            try container.encode(dictionary.mapValues { AnyCodable($0) })
        default:
            throw EncodingError.invalidValue(value, .init(codingPath: [], debugDescription: "Cannot encode value"))
        }
    }
}

*/
